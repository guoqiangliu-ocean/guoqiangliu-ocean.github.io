<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Guoqiang Liu - Physical Oceanographer</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  font-family: "Times New Roman", Times, serif;
}

/* 动态粒子画布 */
#particle-canvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -2;
}

/* 暗化滤镜，保证文字可读 */
.overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.35);
  z-index: -1;
}

/* 顶部导航 */
.topnav {
  position: fixed;
  top: 0;
  width: 100%;
  height: 55px;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  padding: 0 50px;
  box-sizing: border-box;
  z-index: 10;
  backdrop-filter: blur(5px);
  border-bottom: 1px solid rgba(0, 255, 230, 0.1);
}

.topnav a {
  color: #e0f7ff;
  text-decoration: none;
  margin-right: 30px;
  font-weight: 500;
  transition: color 0.3s ease;
  position: relative;
  padding: 5px 0;
}

.topnav a:hover {
  color: #00FFE6;
}

.topnav a::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 0;
  height: 2px;
  background: #00FFE6;
  transition: width 0.3s ease;
}

.topnav a:hover::after {
  width: 100%;
}

main {
  max-width: 900px;
  margin: 140px auto 160px;
  padding: 50px 60px;
  background: rgba(255, 255, 255, 0.95);
  box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
  border-radius: 10px;
  border: 1px solid rgba(0, 255, 230, 0.1);
  position: relative;
  overflow: hidden;
}

main::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, #00FFE6, #8A2BE2);
}

h1 {
  color: #0A1A2F;
  font-size: 2.8rem;
  margin-bottom: 1.5rem;
  font-weight: 700;
  letter-spacing: -0.5px;
}

p {
  color: #333;
  font-size: 1.2rem;
  line-height: 1.7;
  margin-bottom: 1.5rem;
}

/* 响应式调整 */
@media (max-width: 768px) {
  .topnav {
    padding: 0 20px;
    height: 50px;
  }
  
  .topnav a {
    margin-right: 20px;
    font-size: 0.9rem;
  }
  
  main {
    margin: 120px 20px 100px;
    padding: 30px;
  }
  
  h1 {
    font-size: 2.2rem;
  }
  
  p {
    font-size: 1.1rem;
  }
}

/* 加载动画 */
.loading {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #0A1A2F;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  transition: opacity 0.5s ease;
}

.loading-content {
  text-align: center;
  color: #00FFE6;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 3px solid rgba(0, 255, 230, 0.3);
  border-top-color: #00FFE6;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 20px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.loading-text {
  font-size: 1.2rem;
  letter-spacing: 1px;
}
</style>
</head>

<body>
<!-- 加载动画 -->
<div class="loading" id="loading">
  <div class="loading-content">
    <div class="loading-spinner"></div>
    <div class="loading-text">INITIALIZING OCEAN MODEL</div>
  </div>
</div>

<!-- 动态粒子画布 -->
<canvas id="particle-canvas"></canvas>

<!-- 暗化滤镜 -->
<div class="overlay"></div>

<!-- 顶部导航 -->
<nav class="topnav">
  <a href="index.html">Home</a>
  <a href="cv.html">CV</a>
  <a href="publications.html">Publications</a>
  <a href="research.html">Research</a>
  <a href="contact.html">Contact</a>
</nav>

<!-- 主要内容 -->
<main>
  <h1>Guoqiang Liu</h1>
  <p>
    I am a physical oceanographer with research interests in wave–current interaction,
    upper-ocean dynamics, air–sea coupling, and satellite remote sensing.
  </p>
  <p>
    My work combines numerical modeling, theory, and observations
    to understand ocean surface and mixed-layer processes.
  </p>
  <p>
    The interactive background visualizes ocean particle dynamics and turbulent flow patterns,
    representing the complex physical processes I study in my research.
  </p>
</main>

<script>
// 等待页面完全加载
window.addEventListener('load', function() {
  // 隐藏加载动画
  setTimeout(() => {
    document.getElementById('loading').style.opacity = '0';
    setTimeout(() => {
      document.getElementById('loading').style.display = 'none';
    }, 500);
  }, 1000);
});

// ==================== 动态粒子背景系统 ====================

// 获取Canvas元素和上下文
const canvas = document.getElementById('particle-canvas');
const ctx = canvas.getContext('2d');

// 设置Canvas尺寸
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

// 粒子系统
let particles = [];
let animationId;

// 粒子类
class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 0.3; // 降低速度以获得更优雅的移动
    this.vy = (Math.random() - 0.5) * 0.3;
    this.size = Math.random() * 1.5 + 0.8; // 中等大小粒子
    this.baseSize = this.size;
    this.setColor();
    this.wiggle = Math.random() * Math.PI * 2;
    this.wiggleSpeed = Math.random() * 0.03 + 0.01; // 更慢的摆动
  }
  
  setColor() {
    // 使用海洋蓝色调 - 深蓝色到青色
    const oceanColors = [
      '#0A5F8B', // 深海蓝
      '#1A7FB8', // 中等蓝
      '#2C9FCF', // 浅海蓝
      '#40BFE6', // 青色蓝
      '#00CED1'  // 深青色
    ];
    this.color = oceanColors[Math.floor(Math.random() * oceanColors.length)];
  }
  
  update(mouse) {
    // 粒子漂移运动
    this.x += this.vx;
    this.y += this.vy;
    
    // 添加非常轻微的摆动
    this.wiggle += this.wiggleSpeed;
    this.x += Math.sin(this.wiggle) * 0.05; // 降低摆动幅度
    this.y += Math.cos(this.wiggle * 0.7) * 0.05;
    
    // 鼠标交互效果 - 更柔和
    if (mouse.x !== null && mouse.y !== null) {
      const dx = this.x - mouse.x;
      const dy = this.y - mouse.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < 120) { // 扩大影响范围但降低强度
        const force = (120 - distance) / 120;
        this.vx += (dx / distance) * force * 0.02; // 降低交互强度
        this.vy += (dy / distance) * force * 0.02;
      }
    }
    
    // 边界处理 - 更平滑的反弹
    if (this.x < 0 || this.x > canvas.width) {
      this.vx = -this.vx * 0.9; // 降低反弹强度
    }
    
    if (this.y < 0 || this.y > canvas.height) {
      this.vy = -this.vy * 0.9;
    }
    
    // 速度衰减
    this.vx *= 0.995; // 更慢的衰减
    this.vy *= 0.995;
    
    // 非常轻微的大小变化
    this.size = this.baseSize + Math.sin(this.wiggle * 2) * 0.3;
  }
  
  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fillStyle = this.color;
    ctx.fill();
    
    // 添加柔和的光晕效果
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
    const gradient = ctx.createRadialGradient(
      this.x, this.y, this.size,
      this.x, this.y, this.size * 2.5
    );
    gradient.addColorStop(0, this.color + '60'); // 降低透明度
    gradient.addColorStop(1, this.color + '00');
    ctx.fillStyle = gradient;
    ctx.fill();
  }
}

// 初始化粒子 - 使用精心选择的默认值
function initParticles() {
  particles = [];
  // 使用中等数量的粒子：250个
  for (let i = 0; i < 250; i++) {
    particles.push(new Particle(
      Math.random() * canvas.width,
      Math.random() * canvas.height
    ));
  }
}

// 动画循环
function animate() {
  // 使用深色渐变清除画布
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#0A1A2F'); // 深蓝黑
  gradient.addColorStop(1, '#0B2A4A'); // 稍亮的深蓝
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // 更新并绘制每个粒子
  particles.forEach(particle => {
    particle.update(mouse);
    particle.draw(ctx);
  });
  
  // 绘制粒子间连线 - 更细更透明的连线
  drawConnections();
  
  animationId = requestAnimationFrame(animate);
}

// 绘制粒子间连线
function drawConnections() {
  const maxDistance = 90; // 中等连接距离
  
  for (let i = 0; i < particles.length; i++) {
    for (let j = i + 1; j < particles.length; j++) {
      const dx = particles[i].x - particles[j].x;
      const dy = particles[i].y - particles[j].y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < maxDistance) {
        const opacity = (1 - distance / maxDistance) * 0.2; // 更低的透明度
        ctx.beginPath();
        ctx.moveTo(particles[i].x, particles[i].y);
        ctx.lineTo(particles[j].x, particles[j].y);
        ctx.strokeStyle = particles[i].color.replace(')', `, ${opacity})`).replace('rgb', 'rgba');
        ctx.lineWidth = 0.3; // 更细的连线
        ctx.stroke();
      }
    }
  }
}

// 鼠标交互
const mouse = {
  x: null,
  y: null
};

// 事件监听
window.addEventListener('mousemove', (e) => {
  mouse.x = e.x;
  mouse.y = e.y;
});

window.addEventListener('mouseleave', () => {
  mouse.x = null;
  mouse.y = null;
});

// 窗口大小调整处理
window.addEventListener('resize', () => {
  resizeCanvas();
  initParticles(); // 重新初始化粒子
});

// 初始化
resizeCanvas();
initParticles();
animate();
</script>

</body>
</html>
